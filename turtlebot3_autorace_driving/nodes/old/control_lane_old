#!/usr/bin/env python
# -*- coding: utf-8 -*-

################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# Author: Leon Jung, Gilbert, Ashe Kim
 

 #2
import rospy
import numpy as np
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist
import cv2
from cv_bridge import CvBridge
from sensor_msgs.msg import Image


class ControlLane():
    def __init__(self):
        self.sub_lane = rospy.Subscriber('/control/lane', Float64, self.cbFollowLane, queue_size = 1)
        self.sub_max_vel = rospy.Subscriber('/control/max_vel', Float64, self.cbGetMaxVel, queue_size = 1)
        self.pub_cmd_vel = rospy.Publisher('/control/cmd_vel', Twist, queue_size = 1)

        self.lastError = 0
        self.MAX_VEL = 0.1
        
        self.sub_image = rospy.Subscriber('/camera/image_raw', Image, self.cbImage, queue_size=1)
        self.aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_250)
        self.parameters = cv2.aruco.DetectorParameters_create()
        self.bridge = CvBridge()
            
        rospy.on_shutdown(self.fnShutDown)

    def cbImage(self, image_msg):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(image_msg, "bgr8")
        except Exception as e:
            rospy.logerr(e)
            return

        markers, ids, _ = cv2.aruco.detectMarkers(cv_image, self.aruco_dict, parameters=self.parameters)

        if ids is not None and len(ids) > 0:
            # ARUCO marker detected
            for i in range(len(ids)):
                marker_id = ids[i]
                marker_size = 0.1  # Set the real size of the ARUCO marker in meters (adjust accordingly)

                # Assuming you have the camera intrinsic parameters
                # fx and fy are the focal lengths, cx and cy are the principal points
                fx = 500.0  # Replace with your camera's focal length in pixels
                fy = 500.0  # Replace with your camera's focal length in pixels
                cx = cv_image.shape[1] / 2  # Assuming the principal point is at the center of the image
                cy = cv_image.shape[0] / 2  # Assuming the principal point is at the center of the image

                # Get the marker corners in the image
                corners = markers[i][0]

                # Calculate marker image size (distance between two corners)
                marker_image_size = np.linalg.norm(corners[0] - corners[1])

                # Calculate the distance (depth) using the formula
                depth = (marker_size * fx) / marker_image_size

                rospy.loginfo(f"ARUCO marker {marker_id} detected. Depth: {depth} meters.")
                self.stopRobot()
                
        else:
            # No ARUCO marker detected, continue following the lane
            desired_center =  cv_image.shape[1] // 2# You need to get the desired center for lane following
            self.cbFollowLane(desired_center)
        
            
    def stopRobot(self):
        twist = Twist()
        twist.linear.x = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist)
	
	
    def cbGetMaxVel(self, max_vel_msg):
        self.MAX_VEL = max_vel_msg.data

    def cbFollowLane(self, desired_center):
        center = desired_center.data

        error = center - 500

        Kp = 0.0025
        Kd = 0.007

        angular_z = Kp * error + Kd * (error - self.lastError)
        self.lastError = error
        
        twist = Twist()
        # twist.linear.x = 0.05        
        twist.linear.x = min(self.MAX_VEL * ((1 - abs(error) / 500) ** 2.2), 0.05)
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = -max(angular_z, -2.0) if angular_z < 0 else -min(angular_z, 2.0)
        self.pub_cmd_vel.publish(twist)

    def fnShutDown(self):
        rospy.loginfo("Shutting down. cmd_vel will be 0")

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist) 

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('control_lane')
    node = ControlLane()
    node.main()
