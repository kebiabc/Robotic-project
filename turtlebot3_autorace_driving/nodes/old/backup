#!/usr/bin/env python
import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import CompressedImage
from cv_bridge import CvBridge
import cv2
import numpy as np
from std_msgs.msg import Float64

class ControlLane:
    def __init__(self):
        rospy.init_node('control_lane', anonymous=True)
        self.pub_cmd_vel = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber('/camera/image/compressed', CompressedImage, self.image_callback)
        self.sub_lane = rospy.Subscriber('/control/lane', Float64, self.cbFollowLane, queue_size=1)
        self.sub_max_vel = rospy.Subscriber('/control/max_vel', Float64, self.cbGetMaxVel, queue_size=1)
        self.lastError = 0
        self.MAX_VEL = 0.1

        # Use ArUco detection
        self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_6X6_250)
        self.twist = Twist()
        self.corners, self.ids, self.rejectedImgPoints = None, None, None
        self.flag = 0
        self.stopped = False
        self.counter = None  # Initialize the counter
        self.detector_enabled = True  # Flag to control the ArUco detector state
        self.interval_duration = rospy.Duration(30)  # Set the interval duration in seconds

        self.camera_matrix = np.array([[157.85325, 0, 160.94724],
                                       [0, 157.63912, 107.25425],
                                       [0, 0, 1]])

        self.dist_coeffs = np.array([-0.311590, 0.082363, -0.000079, -0.001038, 0.000000])

        rospy.on_shutdown(self.fnShutDown)
        rospy.spin()

    def image_callback(self, msg):
        
        try:
            np_arr = np.frombuffer(msg.data, np.uint8)
            cv_image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

            # Detect ArUco markers if the detector is enabled
            if self.detector_enabled:
                # rospy.loginfo("Seen an image")
                parameters = cv2.aruco.DetectorParameters()
                detector = cv2.aruco.ArucoDetector(self.aruco_dict, parameters)
                self.corners, self.ids, self.rejectedImgPoints = detector.detectMarkers(gray)

                if self.ids is not None and len(self.ids) > 0:
                    rospy.loginfo("ArUco detected!")
                    self.stop_turtlebot()
                    self.counter = rospy.Time.now()  # Update the class attribute counter
                    self.detector_enabled = False  # Disable the detector
                    # Get the marker size (you need to know the actual size of the marker)
                    marker_size = 0.09  # Set the actual size of the marker in meters

                    # Estimate the pose of the marker
                    rvecs, tvecs, _ = cv2.aruco.estimatePoseSingleMarkers(self.corners, marker_size, self.camera_matrix, self.dist_coeffs)

                    # Calculate the distance from the camera to the marker
                    distance = np.linalg.norm(tvecs[0]) if tvecs is not None else None
                    rospy.loginfo(f"Distance to marker: {distance} meters")        

        except Exception as e:
            rospy.logerr(e)

        # Check the counter status and resume if necessary
        if self.counter is not None and (rospy.Time.now() - self.counter) > self.interval_duration:
            self.resume_turtlebot()

    def stop_turtlebot(self):
        self.stopped = True
        rospy.loginfo("Stopping ")
        self.MAX_VEL = 0
        self.twist.linear.x = 0
        self.twist.linear.y = 0
        self.twist.linear.z = 0
        self.twist.angular.x = 0
        self.twist.angular.y = 0
        self.twist.angular.z = 0
        self.pub_cmd_vel.publish(self.twist)
        self.MAX_VEL = 0
        rospy.sleep(15)
        self.ids = None
        self.MAX_VEL = 0.1

    def cbGetMaxVel(self, max_vel_msg):
        self.MAX_VEL = max_vel_msg.data

    def cbFollowLane(self, desired_center):
        self.ids = None
        center = desired_center.data

        error = center - 500

        Kp = 0.0025
        Kd = 0.007

        angular_z = Kp * error + Kd * (error - self.lastError)
        self.lastError = error

        self.twist.linear.x = min(self.MAX_VEL * ((1 - abs(error) / 500) ** 2.2), 0.05)
        self.twist.linear.y = 0
        self.twist.linear.z = 0
        self.twist.angular.x = 0
        self.twist.angular.y = 0
        self.twist.angular.z = -max(angular_z, -2.0) if angular_z < 0 else -min(angular_z, 2.0)
        self.pub_cmd_vel.publish(self.twist)

    def fnShutDown(self):
        rospy.loginfo("Shutting down. cmd_vel will be 0")
        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist)

    def resume_turtlebot(self):
        self.ids = None
        if self.stopped:
            rospy.loginfo("Resuming TurtleBot3...")
            self.twist.linear.x = 0.1  # Set the desired linear velocity
            self.pub_cmd_vel.publish(self.twist)
            rospy.sleep(2)
            self.stopped = False
            self.detector_enabled = True  # Enable the detector

if __name__ == '__main__':
    try:
        node = ControlLane()

    except rospy.ROSInterruptException:
        pass
